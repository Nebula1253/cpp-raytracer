#ifndef IMAGE_H
#define IMAGE_H

#include "color.h"
#include <vector>
#include <fstream>

class image {
    private:
        int width, height;
        double maxColorValue;
        std::vector<color> pixels;
    public:
        image() {};
        image(int width, int height, std::vector<color> pixels) : width(width), height(height), pixels(pixels), maxColorValue(255.999) {};
        image(std::string filename) {
            //assuming a ppm image, which starts with P(something), followed by width and height, followed by max color value, followed by the pixels
            int maxColorValue;

            std::ifstream file;
            file.open(filename);

            std::string line;

            bool nextLineIsResolution = false;
            bool nextLineIsMaxValue = false;
            while (file) {
                std::getline(file, line);
                if (line[0] == 'P') {
                    nextLineIsResolution = true;
                    continue;
                }

                if (line[0] == '#') continue;

                if (nextLineIsResolution) {
                    nextLineIsResolution = false;
                    std::string widthStr = line.substr(0, line.find(' '));
                    std::string heightStr = line.substr(line.find(' ') + 1);

                    width = std::stoi(widthStr);
                    height = std::stoi(heightStr);
                    nextLineIsMaxValue = true;
                    continue;
                }

                if (nextLineIsMaxValue) {
                    nextLineIsMaxValue = false;
                    maxColorValue = std::stoi(line);
                    continue;
                }

                // if we get here, we're in the pixels section
                // generated line-by-line by copilot
                std::string rStr = line.substr(0, line.find(' '));
                std::string gStr = line.substr(line.find(' ') + 1, line.find_last_of(' '));
                std::string bStr = line.substr(line.find_last_of(' ') + 1);

                double r = std::stoi(rStr) / static_cast<double>(maxColorValue);
                double g = std::stoi(gStr) / static_cast<double>(maxColorValue);
                double b = std::stoi(bStr) / static_cast<double>(maxColorValue);

                pixels.push_back(color(r, g, b));
            }
            file.close();
        }

        // all of these generated by copilot
        int get_width() const { return width; }
        int get_height() const { return height; }
        std::vector<color> get_pixels() const { return pixels; }

        color get_color_at_pixel(int x, int y) const { 
            return pixels[x + (y * width)];
        }
        color get_color_at_pixel(double x, double y) const {
            auto x = std::min(static_cast<int>(x * width), width - 1);
            auto y = std::min(static_cast<int>(y * height), height - 1);
            return get_color_at_pixel(x, y);
        }

        void write_to_file(std::string filename) {
            std::ofstream file;
            file.open(filename);

            file << "P3\n" << width << " " << height << "\n" << maxColorValue << "\n";
            for (int i = 0; i < pixels.size(); i++) {
                write_color(file, pixels[i], maxColorValue); // minor edit here to pass maxColorValue to write_color
            }
            file.close();
        }
};

#endif