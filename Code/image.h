#ifndef IMAGE_H
#define IMAGE_H

#include "color.h"
#include <vector>
#include <fstream>

class image {
    private:
        int width, height;
        double maxColorValue;
        std::vector<color> pixels;
    public:
        image() {};
        image(int width, int height, std::vector<color> pixels) : width(width), height(height), pixels(pixels), maxColorValue(255.999) {};
        image(std::string filename) {
            //assuming a ppm image, which starts with P(something), followed by width and height, followed by max color value, followed by the pixels

            std::ifstream file;
            file.open(filename);

            std::string line;

            bool nextLineIsResolution = false;
            bool nextLineIsMaxValue = false;
            while (file) {
                std::getline(file, line);
                if (line[0] == 'P') {
                    nextLineIsResolution = true;
                    continue;
                }

                if (line[0] == '#') continue;

                if (nextLineIsResolution) {
                    nextLineIsResolution = false;
                    std::string widthStr = line.substr(0, line.find(' '));
                    std::string heightStr = line.substr(line.find(' ') + 1);

                    width = std::stoi(widthStr);
                    height = std::stoi(heightStr);
                    nextLineIsMaxValue = true;
                    continue;
                }

                if (nextLineIsMaxValue) {
                    nextLineIsMaxValue = false;
                    maxColorValue = std::stoi(line);
                    continue;
                }

                // if we get here, we're in the pixels section
            
                // the file is a list of numbers separated by varying amounts of whitespace and newlines, 
                // so read them all into a vector of ints
                // generated by copilot
                std::vector<int> pixelValues;
                std::string currentPixelValue = "";
                for (int i = 0; i < line.length(); i++) {
                    if (line[i] == ' ' || line[i] == '\n') {
                        if (currentPixelValue != "") {
                            pixelValues.push_back(std::stoi(currentPixelValue));
                            currentPixelValue = "";
                        }
                    } else {
                        currentPixelValue += line[i];
                    }
                }
                for (int j = 0; j < pixelValues.size(); j += 3) {
                    double r = pixelValues[j] / static_cast<double>(maxColorValue);
                    double g = pixelValues[j + 1] / static_cast<double>(maxColorValue);
                    double b = pixelValues[j + 2] / static_cast<double>(maxColorValue);

                    pixels.push_back(color(r, g, b));
                }
            }
            file.close();
        }

        // all of these generated by copilot
        int get_width() const { return width; }
        int get_height() const { return height; }
        std::vector<color> get_pixels() const { return pixels; }

        color get_color_at_pixel(int x, int y) const { 
            return pixels[x + (y * width)];
        }
        color get_color_at_pixel(double x, double y) const {
            auto xCoord = static_cast<int>(x * width);
            auto yCoord = static_cast<int>(y * height);
            return get_color_at_pixel(xCoord, yCoord);
        }

        void write_to_file(std::string filename) {
            std::ofstream file;
            file.open(filename);

            file << "P3\n" << width << " " << height << "\n" << static_cast<int>(maxColorValue) << "\n";
            for (int i = 0; i < pixels.size(); i++) {
                write_color(file, pixels[i], maxColorValue + 0.999); // minor edit here to pass maxColorValue to write_color
            }
            file.close();
        }
};

#endif