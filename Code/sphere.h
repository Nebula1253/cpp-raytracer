
#include "shape.h"
#include "material.h"
using std::sqrt;

// ALL GENERATED BY COPILOT
class sphere : public shape {
    // class definition
    private:
        point3 center;
        double radius;
        material mat;
    public:
        sphere() {}
        sphere(const point3& center, double radius)
            : center(center), radius(radius)
        {}
        sphere(const point3& center,  const material& mat, double radius)
            : center(center), radius(radius), mat(mat)
        {}

        point3 get_center() const { return center; }
        double get_radius() const { return radius; }

        material get_material() const override {return mat;}

        double intersection(const ray& r) const override {
            // std::cerr << "THIS IS THE SPHERE INTERSECTION" << std::endl;
            vec3 oc = r.origin() - center;

            // we have an equation to solve: 
            auto a = dot(r.direction(), r.direction());
            auto b = 2.0 * dot(oc, r.direction());
            auto c = dot(oc, oc) - radius*radius;
            auto discriminant = b*b - 4*a*c;

            // return (discriminant >= 0);
            // if (discriminant >= 0) return 1;
            // else return -1;
            // return -1;

            if (discriminant < 0) return -1; // no intersection
            else {
                auto small_t = (-b - sqrt(discriminant)) / (2.0 * a);
                if (small_t < 0) return -1; // no intersection
                else return small_t;
            }
        }

        // copilot babey
        vec3 get_normal(point3 point) const override {
            return unit_vector(point - center);
        }

        color get_diffuse_color(point3 point) const override {
            if (!mat.get_has_texture()) {
                return mat.get_diffuse_color();
            }
            else {
                vec3 thingy = unit_vector(point - center);
                
                auto phi = atan2(-thingy.z(), thingy.x()) + (2 * M_PI);
                auto theta = acos(-thingy.y());

                auto u = phi / (2 * M_PI);
                auto v = theta / M_PI;

                return mat.get_texture().get_color_at_pixel(u, v);
            }
        }
};
